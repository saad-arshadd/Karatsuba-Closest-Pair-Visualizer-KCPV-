# -*- coding: utf-8 -*-
"""DAA_PROJECT_FINAL.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18FTT2ueuH4lJ1lJ3vV-dSZpyyvMnTPVu
"""

import random
import math
import matplotlib.pyplot as plt
from ipywidgets import Dropdown, Button, Output, VBox, HBox, Label
from IPython.display import display, Image
import glob
import ipywidgets as widgets
from anytree import Node, RenderTree, AsciiStyle
from anytree.exporter import DotExporter
from subprocess import run

# Closest Pair of Points
def closest_pair(points):
    points.sort()  # Sort points by x-coordinates

    def closest_recursive(points):
        if len(points) <= 3:
            return brute_force(points)

        mid = len(points) // 2
        left = points[:mid]
        right = points[mid:]

        d1, pair1 = closest_recursive(left)
        d2, pair2 = closest_recursive(right)

        d, closest_pair = (d1, pair1) if d1 < d2 else (d2, pair2)

        mid_x = points[mid][0]
        strip = [p for p in points if abs(p[0] - mid_x) < d]
        strip.sort(key=lambda x: x[1])

        return min((d, closest_pair), strip_closest(strip, d, closest_pair), key=lambda x: x[0])

    def brute_force(points):
        min_dist = float('inf')
        pair = None
        for i in range(len(points) - 1):
            for j in range(i + 1, len(points)):
                dist = euclidean_distance(points[i], points[j])
                if dist < min_dist:
                    min_dist = dist
                    pair = (points[i], points[j])
        return min_dist, pair

    def strip_closest(strip, d, closest_pair):
        min_dist = d
        for i in range(len(strip)):
            for j in range(i + 1, len(strip)):
                if (strip[j][1] - strip[i][1]) >= min_dist:
                    break
                dist = euclidean_distance(strip[i], strip[j])
                if dist < min_dist:
                    min_dist = dist
                    closest_pair = (strip[i], strip[j])
        return min_dist, closest_pair

    def euclidean_distance(p1, p2):
        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)

    return closest_recursive(points)

# Karatsuba Integer Multiplication
def karatsuba(x, y, parent=None):
    # Base case: Single-digit multiplication
    if x < 10 or y < 10:
        result = x * y
        if parent:  # Ensure even the base case attaches a node to the parent
            Node(f"{x} * {y} = {result}", parent=parent)
        return result

    # Find the size of the numbers
    m = max(len(str(x)), len(str(y)))
    m2 = m // 2

    # Split x and y into high and low parts
    high1, low1 = divmod(x, 10**m2)
    high2, low2 = divmod(y, 10**m2)

    # Create a parent node for this level of computation
    node_label = f"{x} * {y} = ?"
    node = Node(node_label, parent=parent)

    # Recursive steps: attach children to the current `node`
    z0 = karatsuba(low1, low2, node)  # Low1 * Low2
    z1 = karatsuba((low1 + high1), (low2 + high2), node)  # (Low1 + High1) * (Low2 + High2)
    z2 = karatsuba(high1, high2, node)  # High1 * High2

    # Karatsuba's formula
    result = (z2 * 10**(2 * m2)) + ((z1 - z2 - z0) * 10**m2) + z0
    node.name = f"{x} * {y} = {result}"  # Update the node with the result
    return result


# Plotting the tree structure
def plot_karatsuba_tree(root):
    DotExporter(root).to_dotfile("karatsuba_tree.dot")
    # Convert .dot file to image and display
    run(["dot", "-Tpng", "karatsuba_tree.dot", "-o", "karatsuba_tree.png"])
    display(Image("karatsuba_tree.png"))


#--------------------------------------------------------------------------------------------------------------------------------------------

# Generating sample points for Closest Pair of Points
def generate_points(num_points=100):
    return [(random.randint(-1000, 1000), random.randint(-1000, 1000)) for _ in range(num_points)]

# Generating sample integers for Integer Multiplication with a maximum of 50 digits
#def generate_large_numbers(num_pairs=10, size=50):
#    return [(random.randint(10**(size-1), 10**size - 1), random.randint(10**(size-1), 10**size - 1)) for _ in range(num_pairs)]

# Generating sample integers for Integer Multiplication with a maximum of 7 digits
def generate_large_numbers(num_pairs=10, size=7):
    return [(random.randint(10**(size-1), 10**size - 1), random.randint(10**(size-1), 10**size - 1)) for _ in range(num_pairs)]

# Save to files
for i in range(10):
    points = generate_points()
    with open(f"closest_pair_input_{i+1}.txt", "w") as file:
        file.write('\n'.join(f"{p[0]} {p[1]}" for p in points))

    numbers = generate_large_numbers(1, 7)
    with open(f"integer_multiplication_input_{i+1}.txt", "w") as file:
        file.write('\n'.join(f"{n[0]} {n[1]}" for n in numbers))

print("Files generated and saved.")

#----------------------------------------------------------------------------------------------------------------------------------------------

# UI Elements
algorithm_dropdown = Dropdown(options=['Select Algorithm', 'Closest Pair of Points', 'Integer Multiplication'],
                              description="Algorithm:", style={'description_width': 'initial'},
                              layout=widgets.Layout(width='60%'))

file_dropdown = Dropdown(options=['Select File'], description="Input File:",
                         style={'description_width': 'initial'},
                         layout=widgets.Layout(width='60%'))
run_button = Button(description="Run Algorithm",
                    layout=widgets.Layout(width='30%', background_color='lightblue'))
output_area = Output()

# Update file dropdown based on selected algorithm
def update_file_options(change):
    if algorithm_dropdown.value == 'Closest Pair of Points':
        file_dropdown.options = sorted(glob.glob("closest_pair_input_*.txt"))
    elif algorithm_dropdown.value == 'Integer Multiplication':
        file_dropdown.options = sorted(glob.glob("integer_multiplication_input_*.txt"))
    else:
        file_dropdown.options = ['Select File']

algorithm_dropdown.observe(update_file_options, names='value')

# Run selected algorithm on the selected file
def on_run_button_clicked(b):
    output_area.clear_output()
    algorithm = algorithm_dropdown.value
    file_path = file_dropdown.value

    if algorithm == 'Closest Pair of Points' and file_path != 'Select File':
        with open(file_path, "r") as file:
            points = [tuple(map(int, line.strip().split())) for line in file]
            distance, closest_points = closest_pair(points)

            # Plot the points and highlight the closest pair
            with output_area:
                print(f"Closest Points: {closest_points[0]} and {closest_points[1]}")
                print(f"Distance between Closest Points: {distance:.2f}")

                plt.figure(figsize=(8, 6))
                x_vals, y_vals = zip(*points)
                plt.scatter(x_vals, y_vals, color='blue', label="Points")
                plt.plot([closest_points[0][0], closest_points[1][0]],
                         [closest_points[0][1], closest_points[1][1]],
                         color='red', linestyle='-', linewidth=2, label="Closest Pair")
                plt.scatter(*zip(*closest_points), color='red')
                plt.title(f"Closest Pair Distance: {distance:.2f}")
                plt.xlabel("X-axis")
                plt.ylabel("Y-axis")
                plt.legend()
                plt.show()

    elif algorithm == 'Integer Multiplication' and file_path != 'Select File':
        with open(file_path, "r") as file:
            x, y = map(int, file.readline().strip().split())
            root = Node(f"{x} * {y}")
            result = karatsuba(x, y, root)

            with output_area:
                print(f"Input Numbers: {x} and {y}")
                print(f"Result of Multiplication: {result}")
                # Plot the tree
                plot_karatsuba_tree(root)

run_button.on_click(on_run_button_clicked)

# Display UI
ui = VBox([algorithm_dropdown, file_dropdown, run_button, output_area])
display(ui)